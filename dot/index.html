<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>DOT MERGE - REPLAY PRO FX+</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            touch-action: none;
            user-select: none;
            background-color: #050505;
            color: #ffffff;
            font-family: 'Inter', 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif;
            overflow: hidden;
        }
        .grid-container {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 12px;
            background: #111;
            padding: 16px;
            border-radius: 24px;
            box-shadow: 0 0 40px rgba(0,0,0,1), inset 0 0 20px rgba(255,255,255,0.02);
            border: 1px solid #222;
            position: relative;
            z-index: 10;
        }
        .cell {
            aspect-ratio: 1;
            background: #1a1a1a;
            border-radius: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 800;
            cursor: pointer;
            position: relative;
            transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: visible;
        }
        .dot {
            width: 82%;
            height: 82%;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 2;
            font-size: 1.3rem;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .selected {
            background: #333 !important;
            transform: scale(1.1) translateY(-2px);
            z-index: 10;
            border: 1px solid rgba(255,255,255,0.2);
        }
        .selected .dot {
            box-shadow: 0 0 35px currentColor, 0 0 60px currentColor;
            filter: brightness(1.2);
        }
        .glow-active {
            animation: aura 2s infinite alternate ease-in-out;
        }
        @keyframes aura {
            0% { box-shadow: 0 0 10px currentColor; opacity: 0.9; }
            100% { box-shadow: 0 0 25px currentColor; opacity: 1; }
        }
        
        @keyframes merge-flash {
            0% { transform: scale(1); filter: brightness(1); }
            30% { transform: scale(1.5); filter: brightness(3); box-shadow: 0 0 80px currentColor, 0 0 120px currentColor; }
            100% { transform: scale(1); filter: brightness(1); }
        }
        .flash {
            animation: merge-flash 0.5s ease-out;
            z-index: 100;
        }

        .progress-container {
            width: 100%;
            height: 10px;
            background: #1a1a1a;
            border-radius: 5px;
            overflow: hidden;
            margin-bottom: 24px;
            border: 1px solid #333;
        }
        #time-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #fff, #aaa);
            box-shadow: 0 0 15px rgba(255,255,255,0.5);
            transition: width 0.1s linear;
        }

        .stats-card {
            background: #111;
            border: 1px solid #222;
            padding: 12px;
            border-radius: 18px;
            position: relative;
        }
        .overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.95);
            backdrop-filter: blur(12px);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 100;
        }
        #replay-badge {
            display: none;
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #ff3b30;
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 10px;
            font-weight: 900;
            letter-spacing: 2px;
            animation: blink 1s infinite;
            z-index: 50;
        }
        @keyframes blink { 50% { opacity: 0.5; } }

        #replay-controls {
            display: none;
            position: fixed;
            bottom: 30px;
            background: rgba(20, 20, 20, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 12px 24px;
            border-radius: 50px;
            backdrop-filter: blur(10px);
            z-index: 200;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            gap: 15px;
            align-items: center;
        }
        .ctrl-btn {
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .ctrl-btn:hover:not(:disabled) { background: rgba(255,255,255,0.1); }
        .ctrl-btn:active:not(:disabled) { transform: scale(0.9); }
        .ctrl-btn:disabled { opacity: 0.2; cursor: not-allowed; }

        .particle {
            position: absolute;
            pointer-events: none;
            border-radius: 50%;
            animation: particle-fade 0.8s ease-out forwards;
            z-index: 50;
            box-shadow: 0 0 15px currentColor;
        }
        @keyframes particle-fade {
            0% { transform: translate(0, 0) scale(1); opacity: 1; filter: brightness(2); }
            100% { transform: translate(var(--tx), var(--ty)) scale(0); opacity: 0; }
        }

        .shockwave {
            position: absolute;
            border-radius: 50%;
            border: 4px solid currentColor;
            transform: translate(-50%, -50%) scale(0.5);
            opacity: 1;
            pointer-events: none;
            animation: shockwave-expand 0.6s ease-out forwards;
            z-index: 40;
            box-shadow: 0 0 30px currentColor, inset 0 0 20px currentColor;
            filter: brightness(2);
        }
        @keyframes shockwave-expand {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 1; border-width: 10px; }
            100% { transform: translate(-50%, -50%) scale(2.5); opacity: 0; border-width: 0px; }
        }

        .floating-score {
            position: absolute;
            color: white;
            font-family: 'Courier New', monospace;
            font-weight: 900;
            font-size: 1.4rem;
            pointer-events: none;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8), 0 0 15px rgba(255,255,255,0.8);
            animation: float-up 1s cubic-bezier(0.2, 0.9, 0.3, 1) forwards;
            z-index: 60;
            white-space: nowrap;
        }
        @keyframes float-up {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            20% { transform: translate(-50%, -150%) scale(1.3); opacity: 1; filter: brightness(1.5); }
            100% { transform: translate(-50%, -300%) scale(1); opacity: 0; }
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-6">

    <div id="replay-badge">REPLAY MODE</div>

    <div id="replay-controls">
        <button id="ctrl-prev" class="ctrl-btn" title="1ステップ戻る">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/></svg>
        </button>
        <button id="ctrl-play-pause" class="ctrl-btn" title="再生/一時停止">
            <svg id="svg-pause" width="28" height="28" viewBox="0 0 24 24" fill="currentColor"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
            <svg id="svg-play" class="hidden" width="28" height="28" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>
        </button>
        <button id="ctrl-next" class="ctrl-btn" title="1ステップ進む">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/></svg>
        </button>
        <div class="h-4 w-px bg-white/20 mx-1"></div>
        <span id="replay-progress" class="text-xs font-mono text-white/60">0 / 0</span>
    </div>

    <div id="start-screen" class="overlay">
        <div class="text-center p-8 max-w-sm w-full">
            <h1 class="text-5xl font-black mb-2 tracking-[0.2em] italic text-white">DOT MERGE</h1>
            <p class="text-gray-500 text-xs mb-8 tracking-[0.3em] uppercase">Replay & Share</p>
            
            <div class="stats-card mb-8 py-6 bg-gradient-to-b from-[#111] to-[#050505]">
                <p class="text-gray-500 text-[10px] font-bold uppercase mb-1">ベストスコア</p>
                <p id="start-best-score" class="text-4xl font-mono font-bold text-white tracking-tighter">0000</p>
            </div>

            <div class="flex flex-col gap-4">
                <button id="start-button" class="w-full py-5 bg-white text-black font-black text-xl rounded-2xl hover:scale-105 transition shadow-[0_0_30px_rgba(255,255,255,0.3)]">
                    ゲーム開始
                </button>
                <label class="w-full py-3 bg-white/10 text-gray-300 font-bold text-sm rounded-xl cursor-pointer hover:bg-white/20 transition text-center border border-white/5">
                    リプレイファイルを読み込む
                    <input type="file" id="import-replay" class="hidden" accept=".json">
                </label>
            </div>
        </div>
    </div>

    <div id="game-ui" class="hidden w-full max-w-md flex flex-col items-center">
        <div class="mb-6 text-center w-full">
            <h1 class="text-2xl font-black mb-4 tracking-[0.2em] text-white italic">DOT MERGE</h1>
            <div class="progress-container">
                <div id="time-bar"></div>
            </div>
            <div class="grid grid-cols-2 gap-4 mb-4">
                <div class="stats-card">
                    <p class="text-gray-500 text-[10px] font-bold uppercase tracking-wider">スコア</p>
                    <p id="score" class="text-2xl font-mono font-bold">0000</p>
                </div>
                <div class="stats-card">
                    <p class="text-gray-500 text-[10px] font-bold uppercase tracking-wider">ベスト</p>
                    <p id="best-score" class="text-2xl font-mono font-bold text-gray-400">0000</p>
                </div>
            </div>

            <div class="stats-card w-full flex items-center justify-between px-4 py-2 border-white/5 mb-4 min-h-[42px]">
                <div class="text-left flex items-center gap-3">
                    <p class="text-gray-500 text-[9px] font-bold uppercase tracking-widest">NEXT DOTS</p>
                    <div id="level-display" class="flex gap-2 items-center font-black text-xs"></div>
                </div>
                <div class="text-right">
                    <p id="next-level-text" class="text-[9px] font-bold text-white/40 uppercase tracking-tighter"></p>
                </div>
            </div>
        </div>
        <div id="game-grid" class="grid-container w-full"></div>
        <div class="w-full mt-8">
            <button id="reset-btn" class="w-full py-4 bg-white/5 hover:bg-white/10 text-gray-500 text-xs font-bold rounded-xl transition border border-white/5 uppercase tracking-widest">
                中断してメニューへ
            </button>
        </div>
    </div>

    <div id="game-over" class="overlay hidden">
        <div class="text-center w-full max-w-sm px-6">
            <h2 class="text-5xl font-black mb-2 text-white italic tracking-tighter uppercase">終了</h2>
            <p id="final-score" class="text-2xl text-white/60 mb-10 font-mono">0</p>
            <div class="flex flex-col gap-3">
                <button id="replay-button" class="py-4 bg-blue-600 text-white font-black rounded-xl hover:scale-105 transition shadow-lg hidden">
                    リプレイを再生
                </button>
                <button id="export-button" class="py-4 bg-emerald-600 text-white font-black rounded-xl hover:scale-105 transition shadow-lg hidden">
                    リプレイを保存 (.json)
                </button>
                <div class="h-px bg-white/10 my-2"></div>
                <button id="restart-button" class="py-4 bg-white text-black font-black rounded-xl hover:scale-105 transition shadow-xl">
                    もう一度挑戦
                </button>
                <button id="back-to-title" class="py-4 bg-white/10 text-gray-400 font-bold rounded-xl hover:bg-white/20 transition">
                    メニューに戻る
                </button>
            </div>
        </div>
    </div>

    <script>
        const GRID_SIZE = 5;
        const INITIAL_TIME = 30;
        const MAX_TIME = 30;
        const TIME_RECOVERY_UNIT = 0.8;
        const COLORS = ['#FF3B30', '#007AFF', '#34C759', '#FFCC00', '#FF9500', '#AF52DE', '#5AC8FA', '#FF2D55', '#00FFCC', '#FF00FF', '#7FFF00', '#FF4500', '#4B0082', '#FF69B4', '#C0C0C0', '#FFD700', '#000080', '#8B0000', '#006400', '#2F4F4F'];
        
        const LEVEL_THRESHOLDS = [
           { score: 500, min: 2 }, { score: 1000, min: 3 }, { score: 2000, min: 4 },
            { score: 3000, min: 5 }, { score: 4000, min: 6 }, { score: 5000, min: 7 },
            { score: 7000, min: 8 }, { score: 10000, min: 9 }, { score: 12000, min: 10 },
            { score: 13000, min: 11 }, { score: 19000, min: 12 }, { score: 25000, min: 13 },
            { score: 50000, min: 14 }, { score: 75000, min: 15 }, { score: 90000, min: 16 }
        ];

        const startScreen = document.getElementById('start-screen');
        const gameUI = document.getElementById('game-ui');
        const gridElement = document.getElementById('game-grid');
        const scoreElement = document.getElementById('score');
        const bestScoreElement = document.getElementById('best-score');
        const startBestScore = document.getElementById('start-best-score');
        const timeBar = document.getElementById('time-bar');
        const gameOverElement = document.getElementById('game-over');
        const replayBadge = document.getElementById('replay-badge');
        const replayControls = document.getElementById('replay-controls');
        const replayProgress = document.getElementById('replay-progress');
        const playPauseBtn = document.getElementById('ctrl-play-pause');
        const svgPlay = document.getElementById('svg-play');
        const svgPause = document.getElementById('svg-pause');
        const importInput = document.getElementById('import-replay'); 
        const replayButton = document.getElementById('replay-button');
        const exportButton = document.getElementById('export-button');
        const levelDisplay = document.getElementById('level-display');
        const nextLevelText = document.getElementById('next-level-text');

        let score = 0;
        let timeLeft = INITIAL_TIME;
        let bestScore = parseInt(localStorage.getItem('dotmerge_v3_best')) || 0;
        let grid = [];
        let selectedChain = [];
        let isDragging = false;
        let gameActive = false;
        let timerInterval = null;

        let isReplaying = false;
        let isPaused = false;
        let isProcessing = false; // 連打防止用フラグ
        let currentActionIndex = 0;
        let replayLog = { version: "1.1", score: 0, initialGrid: [], actions: [], randomPool: [] };
        let randomCursor = 0;
        let stateHistory = []; 

        // --- エフェクト関数 ---
        
        function spawnParticles(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                const p = document.createElement('div');
                p.className = 'particle';
                p.style.backgroundColor = color;
                const angle = Math.random() * Math.PI * 2;
                const velocity = Math.random() * 80 + 30; 
                const tx = Math.cos(angle) * velocity;
                const ty = Math.sin(angle) * velocity;
                p.style.setProperty('--tx', `${tx}px`);
                p.style.setProperty('--ty', `${ty}px`);
                const size = Math.random() * 6 + 3;
                p.style.width = `${size}px`;
                p.style.height = `${size}px`;
                p.style.left = `${x}px`;
                p.style.top = `${y}px`;
                document.body.appendChild(p);
                p.addEventListener('animationend', () => p.remove());
            }
        }

        function spawnShockwave(x, y, color) {
            const el = document.createElement('div');
            el.className = 'shockwave';
            el.style.left = `${x}px`;
            el.style.top = `${y}px`;
            el.style.color = color;
            el.style.width = '100px';
            el.style.height = '100px';
            document.body.appendChild(el);
            el.addEventListener('animationend', () => el.remove());
        }

        function showFloatingScore(x, y, amount, isBonus) {
            const el = document.createElement('div');
            el.className = 'floating-score';
            el.textContent = `+${amount}`;
            el.style.left = `${x}px`;
            el.style.top = `${y}px`;
            if (isBonus) {
                el.style.color = '#FFD700';
                el.style.fontSize = '1.8rem';
            }
            document.body.appendChild(el);
            el.addEventListener('animationend', () => el.remove());
        }

        function getCurrentMin(currentScore) {
            let min = 1;
            for (const t of LEVEL_THRESHOLDS) if (currentScore >= t.score) min = t.min;
            return min;
        }

        function updateStrategyUI(currentScore) {
            const min = getCurrentMin(currentScore);
            const max = min + 1;
            const minColor = COLORS[(min - 1) % COLORS.length];
            const maxColor = COLORS[(max - 1) % COLORS.length];

            levelDisplay.innerHTML = `
                <div class="w-3 h-3 rounded-full" style="background:${minColor}; box-shadow: 0 0 5px ${minColor}"></div>
                <span>${min}</span>
                <span class="text-gray-600">~</span>
                <div class="w-3 h-3 rounded-full" style="background:${maxColor}; box-shadow: 0 0 5px ${maxColor}"></div>
                <span>${max}</span>
            `;

            const next = LEVEL_THRESHOLDS.find(t => currentScore < t.score);
            if (next) {
                const diff = next.score - currentScore;
                nextLevelText.textContent = `NEXT LEVEL: ${diff.toLocaleString()}`;
            } else {
                nextLevelText.textContent = `MAX LEVEL`;
            }
        }

        function getNextValue() {
            if (isReplaying) {
                return replayLog.randomPool[randomCursor++];
            } else {
                const val = Math.floor(Math.random() * 2) + getCurrentMin(score);
                replayLog.randomPool.push(val);
                return val;
            }
        }

        function showTitleScreen() {
            gameActive = false;
            isReplaying = false;
            isPaused = false;
            isProcessing = false;
            if (timerInterval) clearInterval(timerInterval);
            startScreen.classList.remove('hidden');
            gameUI.classList.add('hidden');
            gameOverElement.classList.add('hidden');
            replayBadge.style.display = 'none';
            replayControls.style.display = 'none';
            startBestScore.textContent = String(bestScore).padStart(4, '0');
        }

        function initGame() {
            startScreen.classList.add('hidden');
            gameOverElement.classList.add('hidden');
            gameUI.classList.remove('hidden');
            replayBadge.style.display = 'none';
            replayControls.style.display = 'none';
            gridElement.innerHTML = '';
            grid = [];
            score = 0;
            timeLeft = INITIAL_TIME;
            gameActive = true;
            isReplaying = false;
            isProcessing = false;
            selectedChain = [];
            stateHistory = [];
            replayLog = { version: "1.1", score: 0, initialGrid: [], actions: [], randomPool: [] };
            randomCursor = 0;
            updateScoreUI();
            bestScoreElement.textContent = String(bestScore).padStart(4, '0');
            for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
                const val = Math.floor(Math.random() * 2) + 1;
                replayLog.initialGrid.push(val); 
                const cell = createCell(i, val);
                gridElement.appendChild(cell.element);
                grid.push(cell);
            }
            startTimer();
        }

        function createCell(index, value) {
            const el = document.createElement('div');
            el.className = 'cell';
            el.dataset.index = index;
            const dot = document.createElement('div');
            dot.className = 'dot';
            updateDotVisuals(dot, value);
            el.appendChild(dot);
            return { element: el, dot: dot, value: value, index: index };
        }

        function updateDotVisuals(dot, value) {
            const color = COLORS[(value - 1) % COLORS.length] || '#333';
            dot.style.backgroundColor = color;
            dot.style.color = '#fff';
            dot.textContent = value || '';
            dot.style.fontSize = value >= 10 ? '1.1rem' : '1.3rem';
            if (value >= 5) dot.classList.add('glow-active');
            else dot.classList.remove('glow-active');
        }

        async function startReplay() {
            if (replayLog.actions.length === 0) return;
            startScreen.classList.add('hidden');
            gameOverElement.classList.add('hidden');
            gameUI.classList.remove('hidden');
            replayBadge.style.display = 'block';
            replayControls.style.display = 'flex';
            gridElement.innerHTML = '';
            grid = [];
            score = 0;
            gameActive = false;
            isReplaying = true;
            isPaused = false;
            isProcessing = false;
            randomCursor = 0;
            currentActionIndex = 0;
            stateHistory = [];
            updateScoreUI();
            updateReplayUI();
            replayLog.initialGrid.forEach((val, i) => {
                const cell = createCell(i, val);
                gridElement.appendChild(cell.element);
                grid.push(cell);
            });
            playReplayLoop();
        }

        async function playReplayLoop() {
            while (isReplaying && currentActionIndex < replayLog.actions.length) {
                if (isPaused) {
                    await new Promise(r => setTimeout(r, 100));
                    continue;
                }
                await runNextStep();
                await new Promise(r => setTimeout(r, 600)); // 再生の間隔
            }
            if (isReplaying && currentActionIndex >= replayLog.actions.length) {
                setTimeout(() => endGame(), 1000);
            }
        }

        async function runNextStep() {
            if (isProcessing || currentActionIndex >= replayLog.actions.length) return;
            isProcessing = true;
            saveCurrentState();
            
            const action = replayLog.actions[currentActionIndex];
            
            // 選択アニメーション
            for (const idx of action.chain) {
                selectedChain.push(idx);
                grid[idx].element.classList.add('selected');
                await new Promise(r => setTimeout(r, 50));
            }
            
            await new Promise(r => setTimeout(r, 100));
            
            // マージ処理 (内部で refillGrid まで呼ぶ)
            await mergeChain();
            
            selectedChain = [];
            currentActionIndex++;
            updateReplayUI();
            isProcessing = false;
        }

        async function runPrevStep() {
            if (isProcessing || stateHistory.length === 0) return;
            isProcessing = true;
            
            const prevState = stateHistory.pop();
            score = prevState.score;
            randomCursor = prevState.randomCursor;
            
            grid.forEach((cell, i) => {
                cell.value = prevState.gridValues[i];
                updateDotVisuals(cell.dot, cell.value);
                cell.element.classList.remove('selected');
                cell.dot.classList.remove('flash');
            });
            
            currentActionIndex--;
            updateScoreUI();
            updateReplayUI();
            
            isProcessing = false;
        }

        function saveCurrentState() {
            stateHistory.push({ score: score, randomCursor: randomCursor, gridValues: grid.map(c => c.value) });
        }

        function updateReplayUI() {
            replayProgress.textContent = `${currentActionIndex} / ${replayLog.actions.length}`;
            document.getElementById('ctrl-prev').disabled = currentActionIndex === 0 || isProcessing;
            document.getElementById('ctrl-next').disabled = currentActionIndex >= replayLog.actions.length || isProcessing;
            if (isPaused) { svgPlay.classList.remove('hidden'); svgPause.classList.add('hidden'); }
            else { svgPlay.classList.add('hidden'); svgPause.classList.remove('hidden'); }
        }

        function startTimer() {
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                if (!gameActive) return;
                timeLeft -= (0.05 * (1 + (score / 500000)));
                updateTimeBar();
                if (timeLeft <= 0) endGame();
            }, 50);
        }

        function updateTimeBar() {
            timeBar.style.width = Math.max(0, (timeLeft / MAX_TIME) * 100) + '%';
        }

        function areNeighbors(idx1, idx2) {
            const p1 = { x: idx1 % GRID_SIZE, y: Math.floor(idx1 / GRID_SIZE) };
            const p2 = { x: idx2 % GRID_SIZE, y: Math.floor(idx2 / GRID_SIZE) };
            return Math.abs(p1.x - p2.x) <= 1 && Math.abs(p1.y - p2.y) <= 1 && idx1 !== idx2;
        }

        function mergeChain() {
            return new Promise((resolve) => {
                const lastIndex = selectedChain[selectedChain.length - 1];
                const originalValue = grid[lastIndex].value;
                const gain = selectedChain.length * originalValue * 25;
                updateScore(gain);
                
                const rect = grid[lastIndex].element.getBoundingClientRect();
                const cx = rect.left + rect.width / 2;
                const cy = rect.top + rect.height / 2;
                const color = COLORS[(originalValue - 1) % COLORS.length];
                
                spawnParticles(cx, cy, color, Math.min(30, selectedChain.length * 4));
                showFloatingScore(cx, cy, gain, selectedChain.length >= 5);
                spawnShockwave(cx, cy, color);

                if (!isReplaying) {
                    timeLeft = Math.min(MAX_TIME, timeLeft + (selectedChain.length * TIME_RECOVERY_UNIT * Math.max(0.3, 1 - (score / 400000))));
                }

                selectedChain.forEach(idx => {
                    if (idx !== lastIndex) grid[idx].value = 0;
                });
                grid[lastIndex].value = originalValue + 1;
                updateDotVisuals(grid[lastIndex].dot, grid[lastIndex].value);
                grid[lastIndex].dot.classList.add('flash');

                setTimeout(() => {
                    grid[lastIndex].dot.classList.remove('flash');
                    grid.forEach(cell => cell.element.classList.remove('selected'));
                    refillGrid();
                    resolve();
                }, 300);
            });
        }

        function refillGrid() {
            for (let x = 0; x < GRID_SIZE; x++) {
                let empty = 0;
                for (let y = GRID_SIZE - 1; y >= 0; y--) {
                    const idx = y * GRID_SIZE + x;
                    if (grid[idx].value === 0) empty++;
                    else if (empty > 0) {
                        grid[(y + empty) * GRID_SIZE + x].value = grid[idx].value;
                        grid[idx].value = 0;
                    }
                }
                for (let i = 0; i < empty; i++) {
                    grid[i * GRID_SIZE + x].value = getNextValue();
                }
            }
            grid.forEach(cell => {
                updateDotVisuals(cell.dot, cell.value);
            });
        }

        function updateScore(p) {
            score += p;
            updateScoreUI();
            if (score > bestScore) {
                bestScore = score;
                localStorage.setItem('dotmerge_v3_best', bestScore);
            }
        }

        function updateScoreUI() { 
            scoreElement.textContent = String(score).padStart(4, '0');
            updateStrategyUI(score); 
        }

        function endGame() {
            gameActive = false;
            isDragging = false;
            isProcessing = false;
            if (timerInterval) clearInterval(timerInterval);
            document.getElementById('final-score').textContent = score;
            gameOverElement.classList.remove('hidden');
            replayControls.style.display = 'none';
            if (replayLog.actions.length > 0) {
                replayButton.classList.remove('hidden');
                if (!isReplaying) exportButton.classList.remove('hidden');
            }
        }

        document.getElementById('start-button').addEventListener('click', initGame);
        document.getElementById('restart-button').addEventListener('click', initGame);
        document.getElementById('back-to-title').addEventListener('click', showTitleScreen);
        replayButton.addEventListener('click', startReplay);
        exportButton.addEventListener('click', () => {
            const dataStr = JSON.stringify(replayLog);
            const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
            const link = document.createElement('a');
            link.setAttribute('href', dataUri);
            link.setAttribute('download', `replay_${score}.json`);
            link.click();
        });
        document.getElementById('reset-btn').addEventListener('click', showTitleScreen);
        playPauseBtn.addEventListener('click', () => { isPaused = !isPaused; updateReplayUI(); });
        document.getElementById('ctrl-next').addEventListener('click', () => { if (isPaused && !isProcessing) runNextStep(); });
        document.getElementById('ctrl-prev').addEventListener('click', () => { if (isPaused && !isProcessing) runPrevStep(); });
        importInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (ev) => {
                try {
                    replayLog = JSON.parse(ev.target.result);
                    startReplay();
                } catch (err) { console.error("Invalid JSON", err); }
            };
            reader.readAsText(file);
        });

        gridElement.addEventListener('mousedown', (e) => {
            if (!gameActive || isReplaying) return;
            const target = e.target.closest('.cell');
            if (target) { isDragging = true; selectedChain = [parseInt(target.dataset.index)]; grid[selectedChain[0]].element.classList.add('selected'); }
        });
        window.addEventListener('mousemove', (e) => {
            if (!isDragging || !gameActive || isReplaying) return;
            const target = document.elementFromPoint(e.clientX, e.clientY)?.closest('.cell');
            if (target) {
                const idx = parseInt(target.dataset.index);
                const last = selectedChain[selectedChain.length - 1];
                if (idx !== last && grid[idx].value === grid[last].value && areNeighbors(idx, last)) {
                    if (selectedChain.length > 1 && idx === selectedChain[selectedChain.length - 2]) {
                        grid[selectedChain.pop()].element.classList.remove('selected');
                    } else if (!selectedChain.includes(idx)) {
                        selectedChain.push(idx);
                        grid[idx].element.classList.add('selected');
                    }
                }
            }
        });
        window.addEventListener('mouseup', async () => {
            if (!isDragging) return;
            isDragging = false;
            if (selectedChain.length >= 3) { 
                replayLog.actions.push({ chain: [...selectedChain] }); 
                await mergeChain(); 
            }
            else grid.forEach(c => c.element.classList.remove('selected'));
            selectedChain = [];
        });

        gridElement.addEventListener('touchstart', (e) => {
            if (!gameActive || isReplaying) return;
            const target = e.touches[0].target.closest('.cell');
            if (target) { e.preventDefault(); isDragging = true; selectedChain = [parseInt(target.dataset.index)]; grid[selectedChain[0]].element.classList.add('selected'); }
        }, { passive: false });
        window.addEventListener('touchmove', (e) => {
            if (!isDragging || !gameActive || isReplaying) return;
            const target = document.elementFromPoint(e.touches[0].clientX, e.touches[0].clientY)?.closest('.cell');
            if (target) {
                const idx = parseInt(target.dataset.index);
                const last = selectedChain[selectedChain.length - 1];
                if (idx !== last && grid[idx].value === grid[last].value && areNeighbors(idx, last)) {
                    if (selectedChain.length > 1 && idx === selectedChain[selectedChain.length - 2]) {
                        grid[selectedChain.pop()].element.classList.remove('selected');
                    } else if (!selectedChain.includes(idx)) {
                        selectedChain.push(idx);
                        grid[idx].element.classList.add('selected');
                    }
                }
            }
        }, { passive: false });
        window.addEventListener('touchend', async () => {
            if (!isDragging) return;
            isDragging = false;
            if (selectedChain.length >= 3) { 
                replayLog.actions.push({ chain: [...selectedChain] }); 
                await mergeChain(); 
            }
            else grid.forEach(c => c.element.classList.remove('selected'));
            selectedChain = [];
        });

        showTitleScreen();
    </script>
</body>
</html>
